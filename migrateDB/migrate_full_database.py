import csv
import uuid
import sys
import os

class DatabaseMigrator:
    def __init__(self):
        # 旧ID → 新UUID のマッピングを保持
        self.user_id_mapping = {}
        # user_name → user_id のマッピング
        self.name_to_user_id = {}
        # user_icon → user_id のマッピング  
        self.icon_to_user_id = {}
        
    def generate_create_tables_sql(self, output_file):
        """テーブル作成SQLを生成"""
        create_sql = """-- Tankalizerのテーブル定義 (Migration)
-- Generated by migrate_full_database.py

-- users
CREATE TABLE users (
id CHAR(36) PRIMARY KEY DEFAULT (UUID()), 
name VARCHAR(20) NOT NULL,
oauth_app ENUM('github', 'google') NOT NULL,
connect_info VARCHAR(100) NOT NULL,
profile_text VARCHAR(255),
icon_url VARCHAR(255) NOT NULL,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
old_icon_url VARCHAR(255),

UNIQUE (connect_info, oauth_app),
UNIQUE (old_icon_url)
);

-- posts
CREATE TABLE posts (
id CHAR(36) PRIMARY KEY DEFAULT (UUID()), 
original VARCHAR(255) NOT NULL,
tanka JSON NOT NULL,
image_path VARCHAR(255),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
user_id CHAR(36) NOT NULL,
is_deleted BOOL NOT NULL DEFAULT FALSE,

FOREIGN KEY (user_id) REFERENCES users(id)
	ON DELETE CASCADE
	ON UPDATE CASCADE
);

-- miyabis
CREATE TABLE miyabis (
id CHAR(36) PRIMARY KEY DEFAULT (UUID()), 
user_id CHAR(36) NOT NULL,
post_id CHAR(36) NOT NULL,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

UNIQUE (user_id, post_id),

FOREIGN KEY (user_id) REFERENCES users(id)
	ON DELETE CASCADE
	ON UPDATE CASCADE,

FOREIGN KEY (post_id) REFERENCES posts(id)
	ON DELETE CASCADE
	ON UPDATE CASCADE
);

-- developers
CREATE TABLE developers (
  user_id CHAR(36) PRIMARY KEY,
  developer_since TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

-- follows
CREATE TABLE follows (
  follower_id CHAR(36) NOT NULL,
  followee_id CHAR(36) NOT NULL,
  followed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY (follower_id, followee_id),

  FOREIGN KEY (follower_id) REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,

  FOREIGN KEY (followee_id) REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
"""
        with open(output_file, 'w') as f:
            f.write(create_sql)
        print(f"CREATE TABLEs SQL saved to: {output_file}")
        
    def load_users_csv(self, csv_file_path, output_file):
        """usersテーブルのCSVを読み込み、ID マッピングを作成"""
        
        insert_template = """INSERT INTO users (id, name, oauth_app, connect_info, profile_text, icon_url, created_at, old_icon_url) VALUES ('{id}', '{name}', '{oauth_app}', '{connect_info}', {profile_text}, '{icon_url}', '{created_at}', '{old_icon_url}');"""
        
        with open(csv_file_path, 'r', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            
            with open(output_file, 'a') as f:
                f.write("\n-- Users migration\n")
                
                for row in reader:
                    # 新しいUUIDを生成
                    new_id = str(uuid.uuid4())
                    old_id = row['id']
                    
                    # マッピングを保存
                    self.user_id_mapping[old_id] = new_id
                    # postsテーブルのマッピングを保存
                    self.name_to_user_id[row['name']] = new_id
                    # miyabiテーブルのマッピングを保存
                    self.icon_to_user_id[row['icon']] = new_id
                    
                    # 古いフィールドを新しいフィールドにマッピング
                    name = row['name'].replace("'", "''")
                    oauth_app = 'github'
                    connect_info = old_id
                    profile_text = 'NULL'
                    icon_url = row['icon'].replace("'", "''")
                    created_at = row['created_at']
                    old_icon_url = row['icon'].replace("'", "''")
                    
                    # SQL insert文を生成
                    sql = insert_template.format(
                        id=new_id,
                        name=name,
                        oauth_app=oauth_app,
                        connect_info=connect_info,
                        profile_text=profile_text,
                        icon_url=icon_url,
                        created_at=created_at,
                        old_icon_url=old_icon_url
                    )
                    
                    f.write(sql + '\n')
    
    def migrate_posts(self, csv_file_path, output_file):
        """postsテーブルを移行（user_nameからuser_idを取得）"""
        
        with open(csv_file_path, 'r', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            
            with open(output_file, 'a') as f:
                f.write("\n-- Posts migration\n")
                
                for row in reader:
                    # user_name から user_id を取得
                    user_name = row.get('user_name', '')
                    if user_name in self.name_to_user_id:
                        user_id = self.name_to_user_id[user_name]
                    else:
                        print(f"-- Warning: user_name '{user_name}' not found in users mapping", file=sys.stderr)
                        continue
                    
                    # post_idは元のIDをそのまま使用（既にUUID形式）
                    post_id = row.get('id', '')
                    if not post_id:
                        print(f"-- Warning: Empty post_id for row", file=sys.stderr)
                        continue
                    
                    # データの準備
                    original = row.get('original', '').replace("'", "''")
                    # originalが230文字を超える場合は切り詰める（安全マージン）
                    if len(original) > 230:
                        original = original[:230]
                    
                    # tankaカラムの処理（既にJSON形式）
                    tanka_json = row.get('tanka', '[]')
                    if not tanka_json or tanka_json == '':
                        tanka_json = '[]'
                    # シングルクォートをエスケープ
                    tanka_json = tanka_json.replace("'", "''")
                    
                    image_path = row.get('image_path', '').strip()

                    # 空文字列、"NULL"、"null"などをNULLとして扱う
                    if image_path and image_path.upper() != 'NULL':
                        # S3 URLからパス部分のみを抽出
                        if '.com/' in image_path:
                            image_path = image_path.split('.com/')[-1]
                        # SQLクォートをエスケープして、クォートで囲む
                        image_path = f"'{image_path.replace("'", "''")}'"
                    else:
                        # SQLのNULL値（クォートなし）
                        image_path = 'NULL'
                    
                    created_at = row.get('created_at', '')
                    is_deleted = 'FALSE'  # デフォルトはFALSE
                    
                    sql = f"INSERT INTO posts (id, original, tanka, image_path, created_at, user_id, is_deleted) VALUES ('{post_id}', '{original}', '{tanka_json}', {image_path}, '{created_at}', '{user_id}', {is_deleted});"
                    f.write(sql + '\n')
    
    def migrate_miyabi(self, csv_file_path, output_file):
        """miyabiテーブルを移行（user_idをUUIDに変換）"""
        
        with open(csv_file_path, 'r', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            
            with open(output_file, 'a') as f:
                f.write("\n-- Miyabi migration\n")
                
                print(f"icon_to_user_id mapping has {len(self.icon_to_user_id)} entries", file=sys.stderr)
                
                for row in reader:
                    # user_icon から user_id を取得
                    user_icon = row.get('user_icon', '')
                    if user_icon in self.icon_to_user_id:
                        user_id = self.icon_to_user_id[user_icon]
                    else:
                        print(f"-- Warning: user_icon '{user_icon}' not found in users mapping", file=sys.stderr)
                        continue
                    
                    # 新しいUUIDを生成（既にUUID形式の場合はそのまま使用）
                    miyabi_id = row['id']
                    if not self.is_uuid(miyabi_id):
                        miyabi_id = str(uuid.uuid4())
                    
                    post_id = row['post_id']
                    created_at = row['created_at']
                    
                    # Generate SQL insert statement
                    sql = f"INSERT INTO miyabis (id, user_id, post_id, created_at) VALUES ('{miyabi_id}', '{user_id}', '{post_id}', '{created_at}');"
                    f.write(sql + '\n')
    
    def is_uuid(self, value):
        """文字列がUUID形式かチェック"""
        try:
            uuid.UUID(value)
            return True
        except ValueError:
            return False

def main():
    if len(sys.argv) < 2:
        print("Usage: python migrate_full_database.py <directory_with_csvs>", file=sys.stderr)
        print("Example: python migrate_full_database.py .", file=sys.stderr)
        print("\nExpected CSV files:", file=sys.stderr)
        print("  - users.csv", file=sys.stderr)
        print("  - posts.csv (optional)", file=sys.stderr)
        print("  - miyabi.csv", file=sys.stderr)
        sys.exit(1)
    
    directory = sys.argv[1]
    
    # Migratorインスタンスを作成
    migrator = DatabaseMigrator()
    
    try:
        # テーブル作成SQLを生成
        create_tables_file = os.path.join(directory, "create_tables.sql")
        migrator.generate_create_tables_sql(create_tables_file)
        
        # データ移行SQLを生成
        data_migration_file = os.path.join(directory, "data_migration.sql")
        
        # 既存のファイルをクリア
        with open(data_migration_file, 'w') as f:
            f.write("-- Database migration SQL\n")
            f.write("-- Generated by migrate_full_database.py\n")
            f.write("\nSET FOREIGN_KEY_CHECKS = 0;\n")
            f.write("\nBEGIN;\n")
        
        # まずusersテーブルを処理（IDマッピングを作成）
        users_csv = os.path.join(directory, "users.csv")
        if os.path.exists(users_csv):
            migrator.load_users_csv(users_csv, data_migration_file)
        else:
            print(f"Error: users.csv not found in {directory}", file=sys.stderr)
            sys.exit(1)
        
        # postsテーブルを処理
        posts_csv = os.path.join(directory, "posts.csv")
        if os.path.exists(posts_csv):
            migrator.migrate_posts(posts_csv, data_migration_file)
            print(f"Processed posts.csv")
        
        # miyabiテーブルを処理
        miyabi_csv = os.path.join(directory, "miyabi.csv")
        if os.path.exists(miyabi_csv):
            migrator.migrate_miyabi(miyabi_csv, data_migration_file)
            print(f"Processed miyabi.csv")
        
        # Add COMMIT and re-enable foreign key checks at the end
        with open(data_migration_file, 'a') as f:
            f.write("\nCOMMIT;\n")
            f.write("\nSET FOREIGN_KEY_CHECKS = 1;\n")
        
        print(f"\nData migration SQL saved to: {data_migration_file}")
        print("\nMigration complete! Generated files:")
        print(f"1. {create_tables_file} - Run this first to create tables")
        print(f"2. {data_migration_file} - Run this second to insert data")
        
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()